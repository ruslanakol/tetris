<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris‚ò∫</title>
    <style>
        body { margin:0; background:#FCC5CE; color:#222; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; }
        #board { background:#222; touch-action:none; transition: 0.1s; }
        #scoreBox{ margin:10px; font-size:20px; }
        #message {
            font-size: 20px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.6s ease;
            color: #F7C8E0;
        }

        .flash {
            animation: flash 0.3s alternate 3;
        }
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.2; }
        }
    </style>
</head>
<body>

<h2>Tetris for Lerochka‚ò∫</h2>
<div id="scoreBox">
    Score: <span id="score">0</span> | Best: <span id="best">0</span>
</div>

<canvas id="board" width="240" height="480"></canvas>
<p id="message" style="height:30px;margin:10px;font-size:18px;"></p>

<script>
    /* ========= BASIC SETUP ========= */
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const messageEl = document.getElementById("message");


    const COLS = 10, ROWS = 20, SIZE = 24;
    let score = 0;
    let board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    let gameOver = false;

    let best = localStorage.getItem("bestScore") || 0;
    bestEl.textContent = best;

    /* ========= PIECES ========= */
    const phrases = ["–¢–∞–∫ —Ç—Ä–∏–º–∞—Ç–∏! üíõ","–£–≤–∞—É ü§©","–°—É–ø–µ—Ä! üî•","–ö—Ä—É—Ç–æ! üòç","–ü–∏—à–∞—é—Å—å —Ç–æ–±–æ—é! üå∏"];

    const pieces = [
        {s:[[1,1,1],[0,1,0]], c:"#F5768D"}, // T
        {s:[[1,1],[1,1]], c:"#99C2FF"},     // O
        {s:[[1,1,1,1]], c:"#F4DF62"},       // I
        {s:[[1,1,0],[0,1,1]], c:"#FFECDF"}, // S
        {s:[[0,1,1],[1,1,0]], c:"#7CDF64"}, // Z
        {s:[[1,1,1],[1,0,0]], c:"#FF8533"}, // L
        {s:[[1,1,1],[0,0,1]], c:"#00398F"}  // J
    ];

    function newPiece(){
        const p = pieces[Math.floor(Math.random()*pieces.length)];
        return { shape:p.s.map(r=>[...r]), x:3, y:0, color:p.c };
    }

    let piece = newPiece();

    /* ========= DRAWING ========= */
    function drawCell(x,y,color){
        ctx.fillStyle = color;
        ctx.fillRect(x*SIZE,y*SIZE,SIZE-1,SIZE-1);
    }

    function drawBoard(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for(let r=0;r<ROWS;r++){
            for(let c=0;c<COLS;c++){
                if(board[r][c]) drawCell(c,r,board[r][c]);
            }
        }
        piece.shape.forEach((row, y)=>{
            row.forEach((v,x)=>{
                if(v) drawCell(piece.x + x, piece.y + y, piece.color);
            });
        });
    }

    /* ========= GAME LOGIC ========= */
    function collide(px,py,shape){
        return shape.some((row,y)=>row.some((v,x)=>
            v && (py+y>=ROWS || px+x<0 || px+x>=COLS || board[py+y][px+x])
        ));
    }

    function merge(){
        piece.shape.forEach((row,y)=>row.forEach((v,x)=>{
            if(v) board[piece.y+y][piece.x+x] = piece.color;
        }));
    }

    function clearLines(){
        let lines = [];
        for(let r=0; r<ROWS; r++){
            if(board[r].every(c=>c)){
                lines.push(r);
            }
        }
        if(lines.length){
            // –∞–Ω—ñ–º–∞—Ü—ñ—è: –º–æ—Ä–≥–Ω—É—Ç–∏
            lines.forEach(r=>{
                board[r] = board[r].map(()=> "#fff");
            });
            drawBoard();

            setTimeout(()=>{
                board = board.filter(r => !r.every(c=>c));
                while(board.length < ROWS) board.unshift(Array(COLS).fill(0));
                score += lines.length * 100;
                scoreEl.textContent = score;

                // –ø–æ–∫–∞–∑–∞—Ç–∏ —Ñ—Ä–∞–∑—É
                const phrase = phrases[Math.floor(Math.random()*phrases.length)];
                messageEl.textContent = phrase;
                setTimeout(()=> messageEl.textContent = "", 1200);

                drawBoard();
            }, 200);
        }
    }

    function rotate(){
        const r = piece.shape[0].map((_,i)=>piece.shape.map(r=>r[i]).reverse());
        if(!collide(piece.x,piece.y,r)) piece.shape = r;
    }

    function dropStep(){
        if(collide(piece.x,piece.y+1,piece.shape)){
            merge(); clearLines();
            piece = newPiece();
            if(collide(piece.x,piece.y,piece.shape)){
                gameOver = true;
                if(score > best) localStorage.setItem("bestScore",score);
                alert("Game Over!");
                location.reload();
            }
        } else {
            piece.y++;
        }
        drawBoard();
    }

    setInterval(()=>{ if(!gameOver) dropStep(); }, 500);

    /* ========= TOUCH CONTROLS ========= */
    let sx=0, sy=0;

    canvas.addEventListener("touchstart", e=>{
        sx = e.touches[0].clientX;
        sy = e.touches[0].clientY;
    });

    canvas.addEventListener("touchend", e=>{
        if(gameOver) return;

        let ex = e.changedTouches[0].clientX;
        let ey = e.changedTouches[0].clientY;
        let dx = ex - sx, dy = ey - sy;

        // TAP ‚Üí ROTATE
        if(Math.abs(dx)<10 && Math.abs(dy)<10){
            rotate(); drawBoard(); return;
        }

        // SWIPES
        if(Math.abs(dx)>Math.abs(dy)){
            if(dx>40 && !collide(piece.x+1,piece.y,piece.shape)) piece.x++;
            if(dx<-40 && !collide(piece.x-1,piece.y,piece.shape)) piece.x--;
        } else if(dy>40){
            // hard drop
            while(!collide(piece.x,piece.y+1,piece.shape)) piece.y++;
            dropStep();
        }

        setTimeout(drawBoard, 50); // ‚ú® –ø–ª–∞–≤–Ω—ñ—Å—Ç—å
    });


    drawBoard();
</script>
</body>
</html>
