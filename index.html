<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris Mobile</title>
    <style>
        body { margin:0; background:#111; color:#fff; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; }
        #board { background:#222; touch-action:none; }
        #scoreBox{ margin:10px; font-size:20px; }
    </style>
</head>
<body>

<h2>Mobile Tetris</h2>
<div id="scoreBox">
    Score: <span id="score">0</span> | Best: <span id="best">0</span>
</div>

<canvas id="board" width="240" height="480"></canvas>

<script>
    /* ========= BASIC SETUP ========= */
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");

    const COLS = 10, ROWS = 20, SIZE = 24;
    let score = 0;
    let board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    let gameOver = false;

    let best = localStorage.getItem("bestScore") || 0;
    bestEl.textContent = best;

    /* ========= PIECES ========= */
    const pieces = [
        {s:[[1,1,1],[0,1,0]], c:"#ff00ff"}, // T
        {s:[[1,1],[1,1]], c:"#ffff00"},     // O
        {s:[[1,1,1,1]], c:"#00ffff"},       // I
        {s:[[1,1,0],[0,1,1]], c:"#00ff00"}, // S
        {s:[[0,1,1],[1,1,0]], c:"#ff0000"}, // Z
        {s:[[1,1,1],[1,0,0]], c:"#ff8800"}, // L
        {s:[[1,1,1],[0,0,1]], c:"#0000ff"}  // J
    ];

    function newPiece(){
        const p = pieces[Math.floor(Math.random()*pieces.length)];
        return { shape:p.s.map(r=>[...r]), x:3, y:0, color:p.c };
    }

    let piece = newPiece();

    /* ========= DRAWING ========= */
    function drawCell(x,y,color){
        ctx.fillStyle = color;
        ctx.fillRect(x*SIZE,y*SIZE,SIZE-1,SIZE-1);
    }

    function drawBoard(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for(let r=0;r<ROWS;r++){
            for(let c=0;c<COLS;c++){
                if(board[r][c]) drawCell(c,r,board[r][c]);
            }
        }
        piece.shape.forEach((row, y)=>{
            row.forEach((v,x)=>{
                if(v) drawCell(piece.x + x, piece.y + y, piece.color);
            });
        });
    }

    /* ========= GAME LOGIC ========= */
    function collide(px,py,shape){
        return shape.some((row,y)=>row.some((v,x)=>
            v && (py+y>=ROWS || px+x<0 || px+x>=COLS || board[py+y][px+x])
        ));
    }

    function merge(){
        piece.shape.forEach((row,y)=>row.forEach((v,x)=>{
            if(v) board[piece.y+y][piece.x+x] = piece.color;
        }));
    }

    function clearLines(){
        board = board.filter(r => !r.every(c=>c));
        while(board.length < ROWS) board.unshift(Array(COLS).fill(0));
        score += 100;
        scoreEl.textContent = score;
    }

    function rotate(){
        const r = piece.shape[0].map((_,i)=>piece.shape.map(r=>r[i]).reverse());
        if(!collide(piece.x,piece.y,r)) piece.shape = r;
    }

    function dropStep(){
        if(collide(piece.x,piece.y+1,piece.shape)){
            merge(); clearLines();
            piece = newPiece();
            if(collide(piece.x,piece.y,piece.shape)){
                gameOver = true;
                if(score > best) localStorage.setItem("bestScore",score);
                alert("Game Over!");
                location.reload();
            }
        } else {
            piece.y++;
        }
        drawBoard();
    }

    setInterval(()=>{ if(!gameOver) dropStep(); }, 500);

    /* ========= TOUCH CONTROLS ========= */
    let sx=0, sy=0;

    canvas.addEventListener("touchstart", e=>{
        sx = e.touches[0].clientX;
        sy = e.touches[0].clientY;
    });

    canvas.addEventListener("touchend", e=>{
        if(gameOver) return;
        let ex = e.changedTouches[0].clientX;
        let ey = e.changedTouches[0].clientY;
        let dx = ex - sx, dy = ey - sy;

        // TAP â†’ ROTATE
        if(Math.abs(dx)<10 && Math.abs(dy)<10){
            rotate(); drawBoard(); return;
        }

        // SWIPES
        if(Math.abs(dx)>Math.abs(dy)){
            if(dx>40 && !collide(piece.x+1,piece.y,piece.shape)) piece.x++;
            if(dx<-40 && !collide(piece.x-1,piece.y,piece.shape)) piece.x--;
        } else if(dy>40){
            // hard drop
            while(!collide(piece.x,piece.y+1,piece.shape)) piece.y++;
            dropStep();
        }

        drawBoard();
    });

    drawBoard();
</script>
</body>
</html>
